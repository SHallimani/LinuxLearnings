I find its very important that we are clear about the part of Linux we are discussing this topic - Kernel Space or User Space

* ) Scope:
     The scope of mutex is within a process address space which has created it and is used for synchronization of common resource access.
     Whereas semaphore can be used across processes space and hence it can be used for interprocess synchronization/signaling.
     Hence mutex must be released by same thread which is taking it.
* ) Mutex is lightweight and faster than semaphore (only valid for userspace)
* ) Mutex can be acquired by same thread successfully multiple times with condition that it should release it same number of times.
    Other thread trying to acquire will block. Whereas in case of semaphore if same process tries to acquire it again it blocks as it can be acquired only once

-----------------
    Mutex:
-----------------
Mutual exclusion (mutex) is the de facto most used locking mechanism. To understand how it
works, let's see what its structure looks like in include/linux/mutex.h:

struct mutex {
 /* 1: unlocked, 0: locked, negative: locked, possible waiters */
 atomic_t count;
 spinlock_t wait_lock;
 struct list_head wait_list;
 [...]
};

As we have seen in the section wait queue, there is also a list type field in the structure:
wait_list. The principle of sleeping is the same.
Contenders are removed from the scheduler run queue and put onto the wait list (wait_list) in a
sleep state. The kernel then schedules and executes other tasks. When the lock is released, a
waiter in the wait queue is woken, moved off the wait_list, and scheduled back.

Here is an example of a mutex implementation:
struct mutex my_mutex;
mutex_init(&my_mutex);
/* inside a work or a thread */
mutex_lock(&my_mutex);
access_shared_memory();
mutex_unlock(&my_mutex);
Please have a look at include/linux/mutex.h in the kernel source to see the strict rules you must
respect with mutexes. Here are some of them:
        1/ Only one task can hold the mutex at a time; this is actually not a rule, but a fact
        2/ Multiple unlocks are not permitted
        3/ They must be initialized through the API
        4/ A task holding the mutex may not exit, since the mutex will remain locked, and possible contenders will wait (will sleep) forever
        5/ Memory areas where held locks reside must not be freed
        6/ Held mutexes must not be reinitialized
        7/ Since they involve rescheduling, mutexes may not be used in atomic contexts, such as tasklets and timers

Note:
As with wait_queue, there is no polling mechanism with mutexes. Every time thamutex_unlock is called on a mutex, the kernel checks for waiters in wait_list. If
any, one (and only one) of them is awakened and scheduled; they are woken in
the same order in which they were put to sleep

The mutex subsystem checks and enforces the following rules:
------------------------------------------------------------
    - Only one task can hold the mutex at a time.
    - Only the owner can unlock the mutex.
    - Multiple unlocks are not permitted.
    - Recursive locking/unlocking is not permitted.
    - A mutex must only be initialized via the API (see below).
    - A task may not exit with a mutex held.
    - Memory areas where held locks reside must not be freed.
    - Held mutexes must not be reinitialized.
    - Mutexes may not be used in hardware or software interrupt
      contexts such as tasklets and timers.

These semantics are fully enforced when CONFIG DEBUG_MUTEXES is enabled.
In addition, the mutex debugging code also implements a number of other
features that make lock debugging easier and faster:

    - Uses symbolic names of mutexes, whenever they are printed
      in debug output.
    - Point-of-acquire tracking, symbolic lookup of function names,
      list of all locks held in the system, printout of them.
    - Owner tracking.
    - Detects self-recursing locks and prints out all relevant info.
    - Detects multi-task circular deadlocks and prints out all affected
      locks and tasks (and only those tasks).

-----------------
    Semaphore:
-----------------

-----------------
    SpinLock:
-----------------

